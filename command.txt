go mod init NAME

go get google.golang.org/grpc

go get google.golang.org/protobuf


$env:Path += ";C:\Users\lerrxwsb\go\bin"   
-- set path to protoc.exe

protoc -I api/proto --go_out=pkg/api --go_opt=paths=source_relative --go-grpc_out=pkg/api --go-grpc_opt=paths=source_relative api/proto/adder.proto
-- protoc - compiler
-- -I = include path
-- --go_out=pkg/api - destination dir for generated .pb.go files
-- --go-grpc_out - generate grpc files (.pb.grpc.go)
-- --go-grpc_opt=paths=source_relative
    Аналогічно: зберігає структуру директорій відносно api/proto/.
    Тобто api/proto/adder.proto → pkg/api/adder_grpc.pb.go.
-- api/proto/adder.proto - file to compile/work with

go build -v .\cmd\server\


-------------------------------- evas ------------------------------------------------------------

$env:Path += ";C:\Users\lerrxwsb\evans_windows_amd64"
$env:Path += ";C:\Users\lerrxwsb\protoc-32.1-win64\bin"

evans api/protoadder.proto -p 8080

protoc --go_out=proto-gen/lock --go-grpc_out=proto-gen/lock --go_opt=Mproto/LockService.proto=. --go-grpc_opt=Mproto/LockService.proto=. proto/LockService.proto     
 -- with package name


package main

import (
	"context"
	"log"
	"net"
	"os"
	"time"

	dfsapi "dfs/proto-gen/dfs"
	dfs "dfs/services/dfs"

	"google.golang.org/grpc"
)

func main() {
	args := os.Args[1:]
	if len(args) < 3 {
		log.Fatalf("Usage: dfsserver <port> <extentAddr> <lockAddr>")
	}

	port := args[0]
	extentAddr := args[1]
	lockAddr := args[2]

	log.Printf("[BOOT] DFS server starting...")
	log.Printf("[ARGS] Port=%s, ExtentAddr=%s, LockAddr=%s", port, extentAddr, lockAddr)

	// --- Test connection to Extent ---
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	extentConn, err := grpc.DialContext(ctx, extentAddr,
		grpc.WithInsecure(),
		grpc.WithBlock(),
	)
	if err != nil {
		log.Fatalf("[ERROR] Failed to connect to Extent at %s: %v", extentAddr, err)
	}
	defer extentConn.Close()
	log.Printf("[OK] Connected to Extent service at %s", extentAddr)

	// --- Test connection to Lock ---
	ctx2, cancel2 := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel2()
	lockConn, err := grpc.DialContext(ctx2, lockAddr,
		grpc.WithInsecure(),
		grpc.WithBlock(),
	)
	if err != nil {
		log.Fatalf("[ERROR] Failed to connect to Lock at %s: %v", lockAddr, err)
	}
	defer lockConn.Close()
	log.Printf("[OK] Connected to Lock service at %s", lockAddr)

	// --- Start DFS gRPC server ---
	grpcServer := grpc.NewServer()

	srv, err := dfs.NewDfsServiceServer(lockAddr, extentAddr, grpcServer)
	if err != nil {
		log.Fatalf("[ERROR] failed while starting DFS server: %v", err)
	}
	dfsapi.RegisterDfsServiceServer(grpcServer, srv)

	portStr := ":" + port
	lis, err := net.Listen("tcp", portStr)
	if err != nil {
		log.Fatalf("[ERROR] failed to listen on %s: %v", portStr, err)
	}

	log.Printf("[READY] DFS server is running on port %s", port)

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("[FATAL] failed to serve DFS: %v", err)
	}
}
